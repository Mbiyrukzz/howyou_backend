// signalingServer.js - Enhanced with better connection management
const { WebSocketServer } = require('ws')
const url = require('url')

function setupSignalingServer(server) {
  const wss = new WebSocketServer({ noServer: true })
  const clients = new Map() // Map<userId, {ws, metadata}>
  const callRooms = new Map() // Map<chatId, Set<userId>>
  const typingUsers = new Map() // Map<chatId, Map<userId, timeoutId>>

  // Handle WebSocket upgrade
  server.on('upgrade', (request, socket, head) => {
    const pathname = url.parse(request.url).pathname

    console.log(`ðŸ”Œ WebSocket upgrade request: ${pathname}`)

    if (
      pathname === '/' ||
      pathname === '/notifications' ||
      pathname === '/signaling' ||
      pathname === '/posts'
    ) {
      wss.handleUpgrade(request, socket, head, (ws) => {
        wss.emit('connection', ws, request)
      })
    } else {
      console.warn(`âŒ WebSocket rejected for path: ${pathname}`)
      socket.destroy()
    }
  })

  // Handle new connections
  wss.on('connection', (ws, request) => {
    const params = new URLSearchParams(url.parse(request.url).query)
    const userId = params.get('userId')
    const chatId = params.get('chatId')
    const pathname = url.parse(request.url).pathname

    if (!userId) {
      console.error('âŒ WebSocket connection rejected: Missing userId')
      ws.close(1008, 'Missing userId parameter')
      return
    }

    // Close existing connection for this user if any
    const existingClient = clients.get(userId)
    if (
      existingClient &&
      existingClient.ws.readyState === existingClient.ws.OPEN
    ) {
      console.log(`âš ï¸ Closing existing connection for user: ${userId}`)
      existingClient.ws.close(1000, 'New connection established')
    }

    // Store connection with metadata
    clients.set(userId, {
      ws,
      userId,
      chatId,
      pathname,
      online: true,
      lastActivity: Date.now(),
      connectedAt: Date.now(),
    })

    console.log(`âœ… User connected: ${userId} on ${pathname}`)
    console.log(`ðŸ“Š Total connected clients: ${clients.size}`)

    // If chatId provided, add to call room
    if (chatId) {
      if (!callRooms.has(chatId)) {
        callRooms.set(chatId, new Set())
      }
      callRooms.get(chatId).add(userId)
      console.log(`ðŸ“ž User ${userId} joined call room: ${chatId}`)

      broadcastToRoom(chatId, userId, {
        type: 'user-joined',
        userId,
        chatId,
      })
    }

    // Broadcast online status to all users
    broadcastToAll({
      type: 'user-online',
      userId,
      timestamp: new Date().toISOString(),
    })

    // Send connection confirmation
    ws.send(
      JSON.stringify({
        type: 'connected',
        userId,
        timestamp: new Date().toISOString(),
        onlineUsers: Array.from(clients.keys()),
        endpoint: pathname,
      })
    )

    // Handle messages
    ws.on('message', (message) => {
      try {
        const data = JSON.parse(message)
        handleSignalMessage(userId, data)
      } catch (err) {
        console.error('âŒ Invalid message format:', err)
        ws.send(
          JSON.stringify({
            type: 'error',
            message: 'Invalid message format',
          })
        )
      }
    })

    // Handle disconnection
    ws.on('close', () => {
      clients.delete(userId)
      console.log(`âŒ User disconnected: ${userId}`)
      console.log(`ðŸ“Š Total connected clients: ${clients.size}`)

      // Broadcast offline status
      broadcastToAll({
        type: 'user-offline',
        userId,
        timestamp: new Date().toISOString(),
      })

      // Clear typing indicators
      typingUsers.forEach((chatTyping, chatId) => {
        if (chatTyping.has(userId)) {
          const timeoutId = chatTyping.get(userId)
          clearTimeout(timeoutId)
          chatTyping.delete(userId)

          broadcastToChatMembers(chatId, userId, {
            type: 'typing-stopped',
            userId,
            chatId,
          })
        }
      })

      // Remove from call rooms
      callRooms.forEach((users, roomChatId) => {
        if (users.has(userId)) {
          users.delete(userId)
          broadcastToRoom(roomChatId, userId, {
            type: 'user-left',
            userId,
            chatId: roomChatId,
          })

          if (users.size === 0) {
            callRooms.delete(roomChatId)
          }
        }
      })
    })

    ws.on('error', (error) => {
      console.error(`âŒ WebSocket error for user ${userId}:`, error.message)
    })
  })

  // Handle signaling messages
  function handleSignalMessage(senderId, data) {
    console.log(`ðŸ“¨ Message from ${senderId}:`, data.type)

    // Update last activity
    const client = clients.get(senderId)
    if (client) {
      client.lastActivity = Date.now()
    }

    switch (data.type) {
      // ===== CALL SIGNALING =====
      case 'join-call':
        handleJoinCall(senderId, data)
        break

      case 'webrtc-offer':
        forwardToUser(data.to, {
          type: 'webrtc-offer',
          offer: data.offer,
          from: senderId,
          chatId: data.chatId,
        })
        break

      case 'webrtc-answer':
        forwardToUser(data.to, {
          type: 'webrtc-answer',
          answer: data.answer,
          from: senderId,
          chatId: data.chatId,
        })
        break

      case 'webrtc-ice-candidate':
        forwardToUser(data.to, {
          type: 'webrtc-ice-candidate',
          candidate: data.candidate,
          from: senderId,
          chatId: data.chatId,
        })
        break

      case 'screen-sharing':
        forwardToUser(data.to, {
          type: 'screen-sharing',
          enabled: data.enabled,
          from: senderId,
          chatId: data.chatId,
        })
        break

      case 'end-call':
        handleEndCall(senderId, data)
        break

      // ===== MESSAGING =====
      case 'new-message':
        handleNewMessage(senderId, data)
        break

      case 'message-updated':
        handleMessageUpdated(senderId, data)
        break

      case 'message-deleted':
        handleMessageDeleted(senderId, data)
        break

      case 'message-delivered':
        handleMessageDelivered(senderId, data)
        break

      case 'message-read':
        handleMessageRead(senderId, data)
        break

      // ===== POSTS & STATUSES =====
      case 'new-post':
        handleNewPost(senderId, data)
        break

      case 'post-updated':
        handlePostUpdated(senderId, data)
        break

      case 'post-deleted':
        handlePostDeleted(senderId, data)
        break

      case 'post-liked':
        handlePostLiked(senderId, data)
        break

      case 'post-unliked':
        handlePostUnliked(senderId, data)
        break

      case 'new-status':
        handleNewStatus(senderId, data)
        break

      case 'status-deleted':
        handleStatusDeleted(senderId, data)
        break

      // ===== TYPING INDICATORS =====
      case 'typing-start':
        handleTypingStart(senderId, data)
        break

      case 'typing-stop':
        handleTypingStop(senderId, data)
        break

      case 'update-last-seen':
        handleLastSeenUpdate(senderId, data)
        break

      // ===== PRESENCE =====
      case 'update-status':
        handleStatusUpdate(senderId, data)
        break

      case 'ping':
        const socket = clients.get(senderId)
        if (socket && socket.ws.readyState === socket.ws.OPEN) {
          socket.ws.send(JSON.stringify({ type: 'pong' }))
          socket.lastActivity = Date.now()
        }
        break

      default:
        console.warn('âš ï¸ Unknown message type:', data.type)
    }
  }

  // ===== CALL HANDLERS =====
  function handleJoinCall(userId, data) {
    const { chatId } = data

    if (!callRooms.has(chatId)) {
      callRooms.set(chatId, new Set())
    }

    callRooms.get(chatId).add(userId)
    console.log(`ðŸ“ž User ${userId} joined call room: ${chatId}`)

    broadcastToRoom(chatId, userId, {
      type: 'user-joined',
      userId,
      chatId,
    })
  }

  function handleEndCall(userId, data) {
    const { chatId, remoteUserId, reason } = data

    console.log(`ðŸ”´ User ${userId} ending call in room: ${chatId}`, {
      reason,
      remoteUserId,
    })

    const messageType =
      reason === 'timeout' || reason === 'rejected'
        ? 'call-ended'
        : 'call-ended'

    if (remoteUserId) {
      forwardToUser(remoteUserId, {
        type: messageType,
        userId,
        chatId,
        reason: reason || 'user_ended',
        timestamp: new Date().toISOString(),
      })
      console.log(`âœ… Sent call-ended to specific user: ${remoteUserId}`)
    }

    broadcastToRoom(chatId, userId, {
      type: messageType,
      userId,
      chatId,
      reason: reason || 'user_ended',
      timestamp: new Date().toISOString(),
    })

    if (callRooms.has(chatId)) {
      callRooms.get(chatId).delete(userId)

      if (callRooms.get(chatId).size === 0) {
        callRooms.delete(chatId)
        console.log(`ðŸ§¹ Call room ${chatId} cleaned up`)
      }
    }

    console.log(`âœ… Call ended notification sent for room: ${chatId}`)
  }

  // ===== MESSAGE HANDLERS =====
  function handleNewMessage(senderId, data) {
    const { chatId, message, participants } = data

    console.log(`ðŸ’¬ New message in chat ${chatId} from ${senderId}`)

    participants.forEach((participantId) => {
      if (participantId !== senderId) {
        forwardToUser(participantId, {
          type: 'new-message',
          chatId,
          message,
          senderId,
          timestamp: new Date().toISOString(),
        })
      }
    })

    handleTypingStop(senderId, { chatId })
  }

  function handleMessageDelivered(userId, data) {
    const { messageId, chatId, senderId } = data

    forwardToUser(senderId, {
      type: 'message-delivered',
      messageId,
      chatId,
      deliveredBy: userId,
      timestamp: new Date().toISOString(),
    })
  }

  function handleMessageRead(userId, data) {
    const { messageId, chatId, senderId } = data

    forwardToUser(senderId, {
      type: 'message-read',
      messageId,
      chatId,
      readBy: userId,
      timestamp: new Date().toISOString(),
    })
  }

  function handleMessageUpdated(senderId, data) {
    const { chatId, messageId, message, participants } = data

    console.log(`âœï¸ Message updated in chat ${chatId} by ${senderId}`)

    participants.forEach((participantId) => {
      if (participantId !== senderId) {
        forwardToUser(participantId, {
          type: 'message-updated',
          chatId,
          messageId,
          message,
          senderId,
          timestamp: new Date().toISOString(),
        })
      }
    })
  }

  function handleMessageDeleted(senderId, data) {
    const { chatId, messageId, participants } = data

    console.log(`ðŸ—‘ï¸ Message deleted in chat ${chatId} by ${senderId}`)

    participants.forEach((participantId) => {
      if (participantId !== senderId) {
        forwardToUser(participantId, {
          type: 'message-deleted',
          chatId,
          messageId,
          senderId,
          timestamp: new Date().toISOString(),
        })
      }
    })
  }

  // ===== POST HANDLERS =====
  function handleNewPost(senderId, data) {
    const { post } = data

    console.log(`ðŸ“ Broadcasting new post from ${senderId}:`, post._id)
    console.log(`ðŸ“Š Broadcasting to ${clients.size - 1} other clients`)

    let broadcastCount = 0

    // Broadcast to all connected users EXCEPT sender
    clients.forEach((client, userId) => {
      if (userId !== senderId && client.ws.readyState === client.ws.OPEN) {
        try {
          client.ws.send(
            JSON.stringify({
              type: 'new-post',
              post,
              senderId,
              timestamp: new Date().toISOString(),
            })
          )
          broadcastCount++
          console.log(`  âœ… Sent to user: ${userId}`)
        } catch (err) {
          console.error(`  âŒ Failed to send to user ${userId}:`, err.message)
        }
      }
    })

    console.log(`âœ… Broadcast complete: ${broadcastCount} users notified`)
  }

  function handlePostUpdated(senderId, data) {
    const { postId, post } = data

    console.log(`âœï¸ Broadcasting post update from ${senderId}:`, postId)

    broadcastToAll(
      {
        type: 'post-updated',
        postId,
        post,
        senderId,
        timestamp: new Date().toISOString(),
      },
      senderId
    )
  }

  function handlePostDeleted(senderId, data) {
    const { postId } = data

    console.log(`ðŸ—‘ï¸ Broadcasting post deletion from ${senderId}:`, postId)

    broadcastToAll(
      {
        type: 'post-deleted',
        postId,
        senderId,
        timestamp: new Date().toISOString(),
      },
      senderId
    )
  }

  function handlePostLiked(senderId, data) {
    const { postId, userId, newLikeCount } = data

    console.log(`â¤ï¸ Broadcasting post like from ${senderId}:`, postId)

    broadcastToAll(
      {
        type: 'post-liked',
        postId,
        userId: senderId,
        newLikeCount,
        timestamp: new Date().toISOString(),
      },
      senderId
    )
  }

  function handlePostUnliked(senderId, data) {
    const { postId, userId, newLikeCount } = data

    console.log(`ðŸ’” Broadcasting post unlike from ${senderId}:`, postId)

    broadcastToAll(
      {
        type: 'post-unliked',
        postId,
        userId: senderId,
        newLikeCount,
        timestamp: new Date().toISOString(),
      },
      senderId
    )
  }

  function handleNewStatus(senderId, data) {
    const { status } = data

    console.log(`ðŸ“¸ Broadcasting new status from ${senderId}:`, status._id)
    console.log(`ðŸ“Š Broadcasting to ${clients.size - 1} other clients`)

    let broadcastCount = 0

    // Broadcast to all users EXCEPT sender
    clients.forEach((client, userId) => {
      if (userId !== senderId && client.ws.readyState === client.ws.OPEN) {
        try {
          client.ws.send(
            JSON.stringify({
              type: 'new-status',
              status,
              userId: senderId,
              timestamp: new Date().toISOString(),
            })
          )
          broadcastCount++
          console.log(`  âœ… Sent status to user: ${userId}`)
        } catch (err) {
          console.error(
            `  âŒ Failed to send status to user ${userId}:`,
            err.message
          )
        }
      }
    })

    console.log(
      `âœ… Status broadcast complete: ${broadcastCount} users notified`
    )
  }

  function handleStatusDeleted(senderId, data) {
    const { statusId } = data

    console.log(`ðŸ—‘ï¸ Broadcasting status deletion from ${senderId}:`, statusId)

    broadcastToAll(
      {
        type: 'status-deleted',
        statusId,
        userId: senderId,
        timestamp: new Date().toISOString(),
      },
      senderId
    )
  }

  // ===== TYPING HANDLERS =====
  function handleTypingStart(userId, data) {
    const { chatId, participants } = data

    if (!typingUsers.has(chatId)) {
      typingUsers.set(chatId, new Map())
    }

    const chatTyping = typingUsers.get(chatId)

    if (chatTyping.has(userId)) {
      clearTimeout(chatTyping.get(userId))
    }

    const timeoutId = setTimeout(() => {
      handleTypingStop(userId, { chatId, participants })
    }, 5000)

    chatTyping.set(userId, timeoutId)

    participants.forEach((participantId) => {
      if (participantId !== userId) {
        forwardToUser(participantId, {
          type: 'typing',
          userId,
          chatId,
          isTyping: true,
        })
      }
    })

    console.log(`âŒ¨ï¸ User ${userId} started typing in chat ${chatId}`)
  }

  function handleTypingStop(userId, data) {
    const { chatId, participants } = data

    if (typingUsers.has(chatId)) {
      const chatTyping = typingUsers.get(chatId)

      if (chatTyping.has(userId)) {
        clearTimeout(chatTyping.get(userId))
        chatTyping.delete(userId)
      }
    }

    if (participants) {
      participants.forEach((participantId) => {
        if (participantId !== userId) {
          forwardToUser(participantId, {
            type: 'typing',
            userId,
            chatId,
            isTyping: false,
          })
        }
      })
    }

    console.log(`âŒ¨ï¸ User ${userId} stopped typing in chat ${chatId}`)
  }

  function handleLastSeenUpdate(userId, data) {
    const { chatId, participants } = data

    const client = clients.get(userId)
    if (client) {
      client.lastSeen = Date.now()
    }

    if (participants) {
      participants.forEach((participantId) => {
        if (participantId !== userId) {
          forwardToUser(participantId, {
            type: 'user-last-seen',
            userId,
            chatId,
            timestamp: new Date().toISOString(),
          })
        }
      })
    }

    console.log(`ðŸ‘ï¸ User ${userId} last seen updated in chat ${chatId}`)
  }

  // ===== STATUS HANDLERS =====
  function handleStatusUpdate(userId, data) {
    const { status, customMessage } = data

    const client = clients.get(userId)
    if (client) {
      client.status = status
      client.customMessage = customMessage
    }

    broadcastToAll({
      type: 'user-status-updated',
      userId,
      status,
      customMessage,
      timestamp: new Date().toISOString(),
    })

    console.log(`ðŸ“ User ${userId} status updated to: ${status}`)
  }

  // ===== UTILITY FUNCTIONS =====
  function forwardToUser(userId, message) {
    const client = clients.get(userId)

    if (!client) {
      console.warn(`âš ï¸ User ${userId} not found in clients map`)
      return
    }

    if (client.ws.readyState !== client.ws.OPEN) {
      console.warn(
        `âš ï¸ User ${userId} socket not ready (state: ${client.ws.readyState})`
      )
      return
    }

    try {
      client.ws.send(JSON.stringify(message))
      console.log(`âœ‰ï¸ Forwarded message to ${userId}:`, message.type)
    } catch (err) {
      console.error(`âŒ Failed to send message to ${userId}:`, err.message)
    }
  }

  function broadcastToRoom(chatId, excludeUserId, message) {
    const room = callRooms.get(chatId)

    if (!room) {
      console.warn(`âš ï¸ Room ${chatId} not found`)
      return
    }

    room.forEach((userId) => {
      if (userId !== excludeUserId) {
        forwardToUser(userId, message)
      }
    })
  }

  function broadcastToChatMembers(chatId, excludeUserId, message) {
    clients.forEach((client, userId) => {
      if (userId !== excludeUserId && client.chatId === chatId) {
        forwardToUser(userId, message)
      }
    })
  }

  function broadcastToAll(message, excludeUserId = null) {
    let broadcastCount = 0
    let failedCount = 0

    clients.forEach((client, userId) => {
      if (userId !== excludeUserId) {
        if (client.ws.readyState === client.ws.OPEN) {
          try {
            client.ws.send(JSON.stringify(message))
            broadcastCount++
          } catch (err) {
            console.error(`âŒ Broadcast failed to ${userId}:`, err.message)
            failedCount++
          }
        }
      }
    })

    console.log(
      `ðŸ“¡ Broadcast result: ${broadcastCount} sent, ${failedCount} failed`
    )
  }

  // Keep-alive ping every 30 seconds
  setInterval(() => {
    const now = Date.now()
    clients.forEach((client, userId) => {
      if (client.ws.readyState === client.ws.OPEN) {
        if (now - client.lastActivity > 300000) {
          console.warn(`âš ï¸ Client ${userId} inactive, closing connection`)
          client.ws.close(1000, 'Inactive')
          return
        }

        try {
          client.ws.send(JSON.stringify({ type: 'ping' }))
        } catch (err) {
          console.error(`âŒ Failed to send ping to ${userId}:`, err.message)
        }
      }
    })
  }, 30000)

  // Cleanup inactive connections every minute
  setInterval(() => {
    clients.forEach((client, userId) => {
      if (client.ws.readyState !== client.ws.OPEN) {
        clients.delete(userId)
        console.log(`ðŸ§¹ Cleaned up closed connection for user ${userId}`)
      }
    })
  }, 60000)

  console.log('âœ… WebRTC signaling server initialized')
  console.log(
    'ðŸ“¡ Accepting connections on: /, /notifications, /signaling, /posts'
  )

  return clients
}

module.exports = { setupSignalingServer }
//and this works with posts provider and not chats providers 